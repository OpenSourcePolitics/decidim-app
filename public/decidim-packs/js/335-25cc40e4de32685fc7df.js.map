{"version":3,"file":"js/335-25cc40e4de32685fc7df.js","mappings":"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","sources":["webpack://app/../../../.asdf/installs/ruby/2.7.1/lib/ruby/gems/2.7.0/bundler/gems/decidim-4f7e0ffd5b1e/decidim-core/app/packs/src/decidim/editor/modified_enter.js","webpack://app/../../../.asdf/installs/ruby/2.7.1/lib/ruby/gems/2.7.0/bundler/gems/decidim-4f7e0ffd5b1e/decidim-core/app/packs/src/decidim/editor/attribute_diff.js","webpack://app/../../../.asdf/installs/ruby/2.7.1/lib/ruby/gems/2.7.0/bundler/gems/decidim-4f7e0ffd5b1e/decidim-core/app/packs/src/decidim/editor/modified_backspace_offset1.js","webpack://app/../../../.asdf/installs/ruby/2.7.1/lib/ruby/gems/2.7.0/bundler/gems/decidim-4f7e0ffd5b1e/decidim-core/app/packs/src/decidim/editor/history_override.js","webpack://app/../../../.asdf/installs/ruby/2.7.1/lib/ruby/gems/2.7.0/bundler/gems/decidim-4f7e0ffd5b1e/decidim-core/app/packs/src/decidim/editor/linebreak_module.js","webpack://app/../../../.asdf/installs/ruby/2.7.1/lib/ruby/gems/2.7.0/bundler/gems/decidim-4f7e0ffd5b1e/decidim-core/app/packs/src/decidim/editor/modified_backspace_offset_any.js","webpack://app/../../../.asdf/installs/ruby/2.7.1/lib/ruby/gems/2.7.0/bundler/gems/decidim-4f7e0ffd5b1e/decidim-core/app/packs/src/decidim/editor.js"],"sourcesContent":["/* eslint-disable require-jsdoc */\n\nconst Parchment = Quill.import(\"parchment\")\nconst Delta = Quill.import(\"delta\");\n\nconst getLineFormats = (context) => {\n  return Object.keys(context.format).reduce(\n    (formats, format) => {\n      // See Parchment registry.ts => (1 << 3) | ((1 << 2) - 1) = 8 | 3 = 11\n      const blockScope = 11;\n      if (\n        Parchment.query(format, blockScope) &&\n        !Array.isArray(context.format[format])\n      ) {\n        formats[format] = context.format[format];\n      }\n      return formats;\n    },\n    {},\n  );\n}\n\nconst continueFormats = (quill, context, lineFormats) => {\n  Object.keys(context.format).forEach((name) => {\n    if (typeof lineFormats[name] !== \"undefined\" && lineFormats[name] !== null) {\n      return;\n    }\n    if (Array.isArray(context.format[name])) {\n      return;\n    }\n    if (name === \"link\") {\n      return;\n    }\n    quill.format(name, context.format[name], Quill.sources.USER);\n  });\n}\n\nconst lineBreakHandler = (quill, range, context) => {\n  const currentLeaf = quill.getLeaf(range.index)[0];\n  const nextLeaf = quill.getLeaf(range.index + 1)[0];\n  const previousChar = quill.getText(range.index - 1, 1);\n  const formats = quill.getFormat(range.index);\n\n  if (currentLeaf?.next?.domNode?.tagName === \"A\" || nextLeaf?.parent?.domNode?.tagName === \"A\") {\n    quill.insertEmbed(range.index, \"break\", true, \"user\");\n    quill.removeFormat(range.index, 1, Quill.sources.SILENT)\n  } else {\n    quill.insertEmbed(range.index, \"break\", true, \"user\");\n  }\n\n  if (nextLeaf === null) {\n    quill.insertEmbed(range.index, \"break\", true, \"user\");\n  } else if (context.offset === 1 && previousChar === \"\\n\") {\n    const delta = new Delta().retain(range.index).insert(\"\\n\");\n    quill.updateContents(delta, Quill.sources.USER);\n  }\n\n  Object.keys(formats).forEach((format) => {\n    quill.format(format, context.format[format], Quill.sources.USER);\n  });\n  quill.setSelection(range.index + 1, Quill.sources.SILENT);\n\n  const lineFormats = getLineFormats(context);\n  continueFormats(quill, context, lineFormats);\n};\n\nexport default function addEnterBindings(quill) {\n  quill.keyboard.addBinding({\n    key: 13,\n    shiftKey: true\n  }, (range, context) => {\n    lineBreakHandler(quill, range, context);\n  });\n\n  // HAX: make our SHIFT+ENTER binding the second (first is added below) in order to override Quill defaults\n  quill.keyboard.bindings[13].unshift(quill.keyboard.bindings[13].pop());\n\n  quill.keyboard.addBinding({ key: 13, shiftKey: false }, (range, context) => {\n    const lineFormats = getLineFormats(context);\n    const previousChar = quill.getText(range.index - 1, 1);\n    const nextChar = quill.getText(range.index, 1);\n    const delta = new Delta().retain(range.index).insert(\"\\n\", lineFormats);\n    // const length = context.prefix.length;\n    if (previousChar === \"\" || previousChar === \"\\n\") {\n      if (lineFormats.list && nextChar === \"\\n\") {\n        if (quill.getLength() - range.index > 2) {\n          const endFormatDelta = new Delta().retain(range.index - 1).delete(1);\n          quill.updateContents(endFormatDelta, Quill.sources.USER);\n        } else {\n          // Delete empty list item and end the list\n          const endFormatDelta = new Delta().retain(range.index - 1).delete(1).retain(range.index).insert(\"\\n\");\n          quill.updateContents(endFormatDelta, Quill.sources.USER);\n          quill.setSelection(range.index + 1, Quill.sources.SILENT);\n        }\n      } else {\n        quill.updateContents(delta, Quill.sources.USER);\n        if (context.offset === 1 && previousChar === \"\\n\") {\n          quill.setSelection(range.index + 1, Quill.sources.SILENT);\n        } else {\n          quill.setSelection(range.index + 2, Quill.sources.SILENT);\n        }\n      }\n    } else {\n      quill.updateContents(delta, Quill.sources.USER);\n      quill.setSelection(range.index + 1, Quill.sources.SILENT);\n    }\n    quill.focus();\n\n    continueFormats(quill, context, lineFormats);\n  });\n\n  // Replace the default enter handling because we have modified the break element\n  quill.keyboard.bindings[13].unshift(quill.keyboard.bindings[13].pop());\n  return;\n}\n\n","/* eslint-disable require-jsdoc */\n\n// ORGINAL: https://github.com/quilljs/delta/blob/ddda3bf088cda3ec03d5dbcc1179679d147f3a02/src/AttributeMap.ts\nexport default function attributeDiff(attributes1, attributes2) {\n  let alpha = attributes1;\n  let beta = attributes2;\n  if (typeof alpha !== \"object\") {\n    alpha = {};\n  }\n  if (typeof beta !== \"object\") {\n    beta = {};\n  }\n  const attributes = Object.keys(alpha).concat(Object.keys(beta)).reduce((attrs, key) => {\n    // ORGINAL: import isEqual from 'lodash.isequal'; if (!isEqual(a[key], b[key]))\n    if ((alpha[key] !== beta[key])) {\n      attrs[key] = null;\n      if (beta[key]) {\n        attrs[key] = beta[key]\n      }\n    }\n    return attrs;\n  }, {});\n\n  if (Object.keys(attributes).length > 0) {\n    return attributes;\n  }\n  return null;\n}\n","/* eslint-disable require-jsdoc */\n\nimport attributeDiff from \"src/decidim/editor/attribute_diff\"\n\nconst Delta = Quill.import(\"delta\");\n\nconst previousChar = (quill, range) => {\n  return quill.getText(range.index - 1, 1);\n}\n\nconst beforePreviousChar = (quill, range) => {\n  return quill.getText(range.index - 2, 1);\n}\n\nconst nextChar = (quill, range) => {\n  return quill.getText(range.index, 1);\n}\n\nconst handleListSelection = (quill, range) => {\n  const lastCharacterOfPreviousLine = quill.getText(range.index - 3, 1);\n  if (nextChar(quill, range) === \"\\n\" || lastCharacterOfPreviousLine !== \"\\n\") {\n    quill.setSelection(range.index - 1, Quill.sources.SILENT);\n  } else {\n    quill.setSelection(range.index - 3, Quill.sources.SILENT);\n  }\n}\n\nconst moveSelectionToPreviousLine = (quill, range) => {\n  const lastCharacterOfPreviousLine = quill.getText(range.index - 3, 1);\n  if (nextChar(quill, range) === \"\\n\" || lastCharacterOfPreviousLine !== \"\\n\") {\n    quill.setSelection(range.index - 1, Quill.sources.SILENT);\n  } else {\n    quill.setSelection(range.index - 3, Quill.sources.SILENT);\n  }\n}\n\nexport default function backspaceBindings(quill) {\n  quill.keyboard.addBinding({ key: 8, offset: 1, collapsed: true }, (range, context) => {\n    let length = 1\n    if ((/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]$/).test(context.prefix)) {\n      length = 2;\n    }\n\n    if (range.index === 0 || quill.getLength() <= 1) {\n      return;\n    }\n    let formats = {};\n    const [line] = quill.getLine(range.index);\n    let delta = new Delta().retain(range.index - length).delete(length);\n    if (context.offset === 1 && previousChar(quill, range) === \"\\n\") {\n      const [prev] = quill.getLine(range.index - 2);\n      if (prev && prev.statics.blotName === \"list-item\") {\n        formats = handleListSelection(quill, range);\n        if (prev !== null && prev.length() > 1) {\n          let curFormats = line.formats();\n          let prevFormats = quill.getFormat(range.index - 2, 1);\n          formats = attributeDiff(curFormats, prevFormats) || {};\n          length += 1;\n        }\n        delta = new Delta().retain(range.index - 2).delete(2);\n        moveSelectionToPreviousLine(quill, range);\n      } else {\n        delta = new Delta().retain(range.index - 1).delete(1);\n        if (range.index < 2) {\n          delta = new Delta().delete(1).retain(range.index + line.length() - 1);\n        } else if (previousChar(quill, range) === \"\\n\" && beforePreviousChar(quill, range) === \"\\n\") {\n          delta = new Delta().retain(range.index - 2).delete(2);\n        }\n      }\n    } else {\n      const [prev] = quill.getLine(range.index - 1);\n      if (prev) {\n        const isPrevLineEmpty =\n          prev.statics.blotName === \"block\" && prev.length() <= 1;\n        if (!isPrevLineEmpty) {\n          const curFormats = line.formats();\n          const prevFormats = quill.getFormat(range.index - 1, 1);\n          formats = attributeDiff(curFormats, prevFormats) || {};\n          if (Object.keys(formats).length > 0) {\n            // line.length() - 1 targets \\n in line, another -1 for newline being deleted\n            const formatDelta = new Delta().retain(range.index + line.length() - 2).retain(1, formats);\n            delta = delta.compose(formatDelta);\n          }\n        }\n      }\n    }\n    quill.updateContents(delta, Quill.sources.USER);\n    if (Object.keys(formats).length > 0) {\n      quill.formatLine(range.index - length, length, formats, Quill.sources.USER);\n    }\n    quill.focus();\n  });\n\n  // Put this backspace binding to second\n  quill.keyboard.bindings[8].splice(1, 0, quill.keyboard.bindings[8].pop());\n}\n","/* eslint-disable require-jsdoc */\n\nconst History = Quill.import(\"modules/history\");\nHistory.DEFAULTS = {\n  delay: 1000,\n  maxStack: 100,\n  userOnly: true\n};\n\n/**\n * Linebreak module brokes quill's default history class.\n * So here we are moving innerHTML to undo and redo stack\n * instead of deltas.\n */\nexport default class HistoryOverride extends History {\n  constructor(quill, options) {\n    super(quill, options);\n    this.lastRecorded = 0;\n    this.ignoreChange = false;\n    this.init = false;\n    this.quill.emitter.on(\"editor-ready\", () => {\n      this.clear();\n      const $input = $(this.quill.container).siblings('input[type=\"hidden\"]');\n      this.stack.undo.push({content: $input.val() || \"\", index: this.quill.getLength() - 2 });\n      this.lastLength = this.quill.getLength();\n    })\n    /* eslint-disable max-params */\n    this.quill.on(Quill.events.EDITOR_CHANGE, (eventName, delta, oldDelta, source) => {\n      if (!delta) {\n        return;\n      }\n      if (!this.init && eventName === \"selection-change\") {\n        this.stack.undo[0].index = delta.index;\n      }\n      if (eventName !== Quill.events.TEXT_CHANGE || this.ignoreChange) {\n        return;\n      }\n\n      if (!this.options.userOnly || source === Quill.sources.USER) {\n        this.record(delta, oldDelta);\n      }\n    });\n    this.quill.keyboard.addBinding({ key: \"Z\", shortKey: true }, this.undo.bind(this));\n    this.quill.keyboard.addBinding({ key: \"Z\", shortKey: true, shiftKey: true }, this.redo.bind(this));\n    if ((/Win/i).test(navigator.platform)) {\n      this.quill.keyboard.addBinding({ key: \"Y\", shortKey: true }, this.redo.bind(this));\n    }\n  }\n  /* eslint-enable max-params */\n\n  change(source, dest) {\n    if (this.stack[source].length === 0) {\n      return;\n    }\n    let obj = this.updateStacks(source, dest);\n    if (!obj.content) {\n      return;\n    }\n    if (!obj.index) {\n      obj.index = 0\n    }\n    this.lastRecorded = 0;\n    this.ignoreChange = true;\n    this.quill.setContents(this.quill.clipboard.convert(obj.content));\n    this.ignoreChange = false;\n    let index = obj.index;\n    this.quill.setSelection(index);\n  }\n\n  updateStacks(source, dest) {\n    if (source === \"undo\") {\n      if (this.stack.undo.length === 1) {\n        return this.stack.undo[0]\n      }\n      this.stack[dest].push(this.stack.undo.pop())\n      return this.stack.undo[this.stack.undo.length - 1]\n    }\n    let content = this.stack.redo.pop();\n    this.stack.undo.push(content)\n    return content\n  }\n\n  record(changeDelta) {\n    if (changeDelta.ops.length === 0) {\n      return\n    } else if (!this.init) {\n      this.init = true;\n    }\n    this.stack.redo = [];\n    let timestamp = Date.now();\n    // Should not return after length check, because after linebreak a keypress replaces invisible characters with\n    // visible characters.\n    // For example: <br><br></p> -> [press X] -> <br>X</p>.\n    if (Math.abs(this.lastLength === this.quill.getLength()) || this.lastRecorded + this.options.delay > timestamp) {\n      if (this.stack.undo.length > 1) {\n        this.stack.undo.pop();\n      }\n    } else {\n      this.lastLength = this.quill.getLength();\n      if (this.lastRecorded + this.options.delay <= timestamp) {\n        this.lastRecorded = timestamp;\n      }\n    }\n    this.stack.undo.push({content: this.quill.container.firstChild.innerHTML, index: this.quill.getSelection()})\n  }\n\n  transform() {\n    return;\n  }\n}\n","/* eslint-disable require-jsdoc */\n\nimport addEnterBindings from \"src/decidim/editor/modified_enter\"\nimport backspaceBindingsRangeAny from \"src/decidim/editor/modified_backspace_offset_any\"\nimport backspaceBindings from \"src/decidim/editor/modified_backspace_offset1\"\nimport HistoryOverride from \"src/decidim/editor/history_override\"\n\n// Disable warning messages from overwritting modules\nQuill.debug(\"error\");\n\n// It all started with these snippets of code: https://github.com/quilljs/quill/issues/252\nconst Delta = Quill.import(\"delta\");\nconst Break = Quill.import(\"blots/break\");\nconst Embed = Quill.import(\"blots/embed\");\nconst Scroll = Quill.import(\"blots/scroll\");\nconst Parchment = Quill.import(\"parchment\");\nQuill.register({\"modules/history\": HistoryOverride}, true);\nlet icons = Quill.import(\"ui/icons\");\nicons.linebreak = \"âŽ\";\n\nclass SmartBreak extends Break {\n  length() {\n    return 1;\n  }\n\n  value() {\n    return \"\\n\";\n  }\n\n  insertInto(parent, ref) {\n    // Embed.prototype.insertInto.call(this, parent, ref);\n    Reflect.apply(Embed.prototype.insertInto, this, [parent, ref]);\n  }\n}\nQuill.register(SmartBreak);\n\n// Override quill/blots/scroll.js\nclass ScrollOvderride extends Scroll {\n  optimize(mutations = [], context = {}) {\n    if (this.batch === true) {\n      return;\n    }\n\n    this.parchmentOptimize(mutations, context);\n\n    if (mutations.length > 0) {\n      // quill/core/emitter.js, Emitter.events.SCROLL_OPTIMIZE = \"scroll-optimize\"\n      this.emitter.emit(\"scroll-optimize\", mutations, context);\n    }\n  }\n\n  // Override parchment/src/blot/scroll.ts\n  parchmentOptimize(mutations = [], context = {}) {\n    // super.optimize(context);\n    Reflect.apply(Parchment.Container.prototype.optimize, this, [context]);\n\n    // We must modify mutations directly, cannot make copy and then modify\n    // let records = [].slice.call(this.observer.takeRecords());\n    let records = [...this.observer.takeRecords()];\n    // Array.push currently seems to be implemented by a non-tail recursive function\n    // so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());\n    while (records.length > 0) {\n      mutations.push(records.pop());\n    }\n    let mark = (blot, markParent) => {\n      if (!blot || blot === this) {\n        return;\n      }\n      if (!blot.domNode.parentNode) {\n        return;\n      }\n      if (blot.domNode.__blot && blot.domNode.__blot.mutations === null) {\n        blot.domNode.__blot.mutations = [];\n      }\n      if (markParent) {\n        mark(blot.parent);\n      }\n    };\n    let optimize = (blot) => {\n      // Post-order traversal\n      if (!blot.domNode.__blot) {\n        return;\n      }\n\n      if (blot instanceof Parchment.Container) {\n        blot.children.forEach(optimize);\n      }\n      blot.optimize(context);\n    };\n    let remaining = mutations;\n    for (let ind = 0; remaining.length > 0; ind += 1) {\n      // MAX_OPTIMIZE_ITERATIONS = 100\n      if (ind >= 100) {\n        throw new Error(\"[Parchment] Maximum optimize iterations reached\");\n      }\n      remaining.forEach((mutation) => {\n        let blot = Parchment.find(mutation.target, true);\n        if (!blot) {\n          return;\n        }\n        if (blot.domNode === mutation.target) {\n          if (mutation.type === \"childList\") {\n            mark(Parchment.find(mutation.previousSibling, false));\n\n            mutation.addedNodes.forEach((node) => {\n              let child = Parchment.find(node, false);\n              mark(child, false);\n              if (child instanceof Parchment.Container) {\n                child.children.forEach(function(grandChild) {\n                  mark(grandChild, false);\n                });\n              }\n            });\n          } else if (mutation.type === \"attributes\") {\n            mark(blot.prev);\n          }\n        }\n        mark(blot);\n      });\n      this.children.forEach(optimize);\n      remaining = [...this.observer.takeRecords()];\n      records = remaining.slice();\n      while (records.length > 0) {\n        mutations.push(records.pop());\n      }\n    }\n  }\n};\nQuill.register(\"blots/scroll\", ScrollOvderride, true);\nParchment.register(ScrollOvderride);\n\n\nexport default function lineBreakButtonHandler(quill) {\n  let range = quill.selection.getRange()[0];\n  let currentLeaf = quill.getLeaf(range.index)[0];\n  let nextLeaf = quill.getLeaf(range.index + 1)[0];\n  const previousChar = quill.getText(range.index - 1, 1);\n\n  // Insert a second break if:\n  // At the end of the editor, OR next leaf has a different parent (<p>)\n  if (nextLeaf === null || (currentLeaf.parent !== nextLeaf.parent)) {\n    quill.insertEmbed(range.index, \"break\", true, \"user\");\n    quill.insertEmbed(range.index, \"break\", true, \"user\");\n  } else if (previousChar === \"\\n\") {\n    const delta = new Delta().retain(range.index).insert(\"\\n\");\n    quill.updateContents(delta, Quill.sources.USER);\n  } else {\n    quill.insertEmbed(range.index, \"break\", true, \"user\");\n  }\n\n  // Now that we've inserted a line break, move the cursor forward\n  quill.setSelection(range.index + 1, Quill.sources.SILENT);\n}\n\nQuill.register(\"modules/linebreak\", (quill) => {\n  quill.getModule(\"toolbar\").addHandler(\"linebreak\", () => {\n    lineBreakButtonHandler(quill);\n  });\n\n  quill.emitter.on(\"editor-ready\", () => {\n    const length = quill.getLength();\n    const text = quill.getText(length - 2, 2);\n\n    // Remove extraneous new lines\n    if (text === \"\\n\\n\") {\n      quill.deleteText(quill.getLength() - 2, 2);\n    }\n  });\n\n  quill.clipboard.addMatcher(\"BR\", (node) => {\n    if (node?.parentNode?.tagName === \"A\") {\n      return new Delta().insert(\"\\n\");\n    }\n    return new Delta().insert({\"break\": \"\"});\n  });\n\n  addEnterBindings(quill);\n  backspaceBindingsRangeAny(quill);\n  backspaceBindings(quill);\n\n  return;\n});\n\n","/* eslint-disable require-jsdoc */\n\nimport attributeDiff from \"src/decidim/editor/attribute_diff\"\n\nexport default function backspaceBindingsRangeAny(quill) {\n  quill.keyboard.addBinding({ key: 8, altKey: null, ctrlKey: null, metaKey: null, shiftKey: null, collapsed: true }, (range, context) => {\n    let length = 1;\n    if (range.index === 0 || quill.getLength() <= 1) {\n      return;\n    }\n    let [line] = quill.getLine(range.index);\n    let formats = {};\n    if (context.offset === 0) {\n      let [prev] = quill.getLine(range.index - 1);\n      if (prev !== null && prev.length() > 1) {\n        let curFormats = line.formats();\n        let prevFormats = quill.getFormat(range.index - 1, 1);\n        formats = attributeDiff(curFormats, prevFormats) || {};\n        const previousLineLength = quill.getLine(range.index - 1)[1];\n        const previousChar = quill.getText(range.index - 1, 1)\n        const beforePreviousChar = quill.getText(range.index - 2, 1);\n        if (previousLineLength && previousLineLength === 1 && beforePreviousChar === \"\\n\") {\n          if (prevFormats && prevFormats.list) {\n            quill.setSelection(range.index - 2, Quill.sources.SILENT);\n          } else if (previousChar === \"\\n\" && beforePreviousChar === \"\\n\") {\n            length += 1;\n          }\n        }\n      }\n    }\n\n    if ((/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]$/).test(context.prefix)) {\n      length += 1;\n    }\n    quill.deleteText(range.index - length, length, Quill.sources.USER);\n\n    if (Object.keys(formats).length > 0) {\n      quill.formatLine(range.index - length, length, formats, Quill.sources.USER);\n    }\n    quill.focus();\n  })\n\n  // Put this backspace binding to second (after backspce_offset1 it's going to be third)\n  quill.keyboard.bindings[8].splice(1, 0, quill.keyboard.bindings[8].pop());\n}\n\n","/* eslint-disable require-jsdoc */\n\nimport lineBreakButtonHandler from \"src/decidim/editor/linebreak_module\"\n\nconst quillFormats = [\"bold\", \"italic\", \"link\", \"underline\", \"header\", \"list\", \"video\", \"image\", \"alt\", \"break\"];\n\nexport default function createQuillEditor(container) {\n  const toolbar = $(container).data(\"toolbar\");\n  const disabled = $(container).data(\"disabled\");\n\n  let quillToolbar = [\n    [\"bold\", \"italic\", \"underline\", \"linebreak\"],\n    [{ list: \"ordered\" }, { list: \"bullet\" }],\n    [\"link\", \"clean\"]\n  ];\n\n  if (toolbar === \"full\") {\n    quillToolbar = [\n      [{ header: [1, 2, 3, 4, 5, 6, false] }],\n      ...quillToolbar,\n      [\"video\"]\n    ];\n  } else if (toolbar === \"basic\") {\n    quillToolbar = [\n      ...quillToolbar,\n      [\"video\"]\n    ];\n  }\n\n  const $input = $(container).siblings('input[type=\"hidden\"]');\n  container.innerHTML = $input.val() || \"\";\n\n  const quill = new Quill(container, {\n    modules: {\n      linebreak: {},\n      toolbar: {\n        container: quillToolbar,\n        handlers: {\n          \"linebreak\": lineBreakButtonHandler\n        }\n      }\n    },\n    formats: quillFormats,\n    theme: \"snow\"\n  });\n\n  if (disabled) {\n    quill.disable();\n  }\n\n  quill.on(\"text-change\", () => {\n    const text = quill.getText();\n\n    // Triggers CustomEvent with the cursor position\n    // It is required in input_mentions.js\n    let event = new CustomEvent(\"quill-position\", {\n      detail: quill.getSelection()\n    });\n    container.dispatchEvent(event);\n\n    if (text === \"\\n\" || text === \"\\n\\n\") {\n      $input.val(\"\");\n    } else {\n      $input.val(quill.root.innerHTML);\n    }\n  });\n  // After editor is ready, linebreak_module deletes two extraneous new lines\n  quill.emitter.emit(\"editor-ready\");\n\n  return quill;\n}\n\n"],"names":["Parchment","Quill","Delta","getLineFormats","context","Object","Array","formats","continueFormats","quill","lineFormats","name","addEnterBindings","key","shiftKey","currentLeaf","range","nextLeaf","previousChar","delta","retain","lineBreakHandler","nextChar","endFormatDelta","attributeDiff","attributes1","alpha","beta","attributes","attrs","backspaceBindings","offset","collapsed","length","line","prev","lastCharacterOfPreviousLine","handleListSelection","moveSelectionToPreviousLine","beforePreviousChar","formatDelta","History","delay","maxStack","userOnly","HistoryOverride","$input","$","content","index","eventName","source","shortKey","navigator","this","stack","obj","updateStacks","lastRecorded","ignoreChange","setContents","clipboard","convert","setSelection","undo","dest","push","redo","changeDelta","init","timestamp","Date","Math","lastLength","options","pop","container","firstChild","getSelection","Break","Embed","Scroll","icons","SmartBreak","Reflect","parent","ScrollOvderride","mutations","batch","parchmentOptimize","emitter","emit","records","observer","mark","blot","optimize","remaining","ind","mutation","child","grandChild","children","forEach","lineBreakButtonHandler","node","altKey","ctrlKey","metaKey","curFormats","prevFormats","previousLineLength","backspaceBindingsRangeAny","quillFormats","createQuillEditor","toolbar","disabled","quillToolbar","list","header","modules","linebreak","handlers","theme","text","event","CustomEvent","detail"],"sourceRoot":""}